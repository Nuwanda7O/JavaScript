<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script>
        /*
        在构造函数里写function 每次创建对象都会执行一次 浪费空间
        把function写在外面 在构造函数里用 obj.fun = fun() 污染了全局变量
        所以用到原型
        
        每个函数里都有一个prototype属性 指向原型对象
        
        普通函数调用时 prototype没有任何用
        作为构造函数调用时 它创建的对象中有一个隐含属性(很像构造函数里的prototype 都指向原型对象)
            指向构造函数的原型对象 通过_proto_访问这个隐含属性

        原型对象相当于公共的区域 同一个类的实例都可以访问原型对象
        可以将对象中共有的内容 统一设置到原型对象中
        */
       function Myclass() {  }
       Myclass.prototype.a = 123;
       var mc = new Myclass();
       console.log(mc.__proto__ == Myclass.prototype); //ture
       console.log(mc.a);//123 mc里没找到 在原型里找到了
       console.log("a" in mc); //true
       console.log(mc.hasOwnProperty("a")); //false
       /*
       原型对象里还有prototype指向一个原型对象
       所以找hasOwnProperty在原型的原型里
       Object对象没有原型 Object中依然没有找到 则返回undefined
       */
    </script>
</head>
<body>
    
</body>
</html>